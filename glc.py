# -*- coding: utf-8 -*-
"""GLC.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1cufwidrj4e5BpZ5Xiqb7NWXqToF_Zxt3
"""

from collections import defaultdict
from itertools import chain, combinations

class Gramática:
    def __init__(self, regras_str):
        self.variaveis = set()
        self.terminais = set()
        self.inicial = None
        self.regras = defaultdict(list)
        self._carregar_gramatica(regras_str)

    def _carregar_gramatica(self, regras_str):
        linhas = [linha.strip() for linha in regras_str.strip().split("\n") if linha.strip()]
        for linha in linhas:
            esquerda, direita = map(str.strip, linha.split("->"))
            if self.inicial is None:
                self.inicial = esquerda
            self.variaveis.add(esquerda)
            producoes = [p.strip() for p in direita.split("|")]
            for prod in producoes:
                simbolos = list(prod) if prod != "ε" else ["ε"]
                self.regras[esquerda].append(simbolos)
                for simbolo in simbolos:
                    if simbolo.islower() or not simbolo.isalpha():
                        self.terminais.add(simbolo)
                    elif simbolo != 'ε':
                        self.variaveis.add(simbolo)

    def exibir(self, titulo="Gramática"):
        print(f"\n {titulo}")
        for var in self.regras:
            producoes = [''.join(p) if p != ['ε'] else 'ε' for p in self.regras[var]]
            print(f"{var} -> {' | '.join(producoes)}")

    def remover_simbolos_inuteis(self):
        geradores = set()
        alterado = True
        while alterado:
            alterado = False
            for A in self.regras:
                for prod in self.regras[A]:
                    if all(s in self.terminais or s in geradores for s in prod):
                        if A not in geradores:
                            geradores.add(A)
                            alterado = True

        self.regras = {A: [p for p in prods if all(s in self.terminais or s in geradores for s in p)]
                       for A, prods in self.regras.items() if A in geradores}
        self.variaveis = set(self.regras.keys())

        acessiveis = set()
        fila = [self.inicial]

        while fila:
            atual = fila.pop()
            if atual not in acessiveis:
                acessiveis.add(atual)
                for prod in self.regras.get(atual, []):
                    for simbolo in prod:
                        if simbolo in self.variaveis and simbolo not in acessiveis:
                            fila.append(simbolo)

        self.regras = {A: [p for p in prods] for A, prods in self.regras.items() if A in acessiveis}
        self.variaveis = set(self.regras.keys())

    def remover_producoes_vazias(self):
        anulaveis = set()
        alterado = True
        while alterado:
            alterado = False
            for A, prods in self.regras.items():
                for prod in prods:
                    if all(s in anulaveis or s == 'ε' for s in prod):
                        if A not in anulaveis:
                            anulaveis.add(A)
                            alterado = True

        novas_regras = defaultdict(list)

        for A, prods in self.regras.items():
            for prod in prods:
                if prod == ['ε']:
                    continue
                subconjuntos = gerar_substituicoes_vazias(prod, anulaveis)
                for p in subconjuntos:
                    if not p:
                        novas_regras[A].append(['ε'])
                    elif p not in novas_regras[A]:
                        novas_regras[A].append(p)

        if self.inicial in anulaveis:
            novas_regras[self.inicial].append(['ε'])

        self.regras = novas_regras

    def substituir_unitarias(self):
        novas_regras = defaultdict(list)

        for A in self.regras:
            fecho = set()
            fila = [A]

            while fila:
                atual = fila.pop()
                for prod in self.regras.get(atual, []):
                    if len(prod) == 1 and prod[0] in self.variaveis:
                        B = prod[0]
                        if B not in fecho:
                            fecho.add(B)
                            fila.append(B)

            for B in fecho | {A}:
                for prod in self.regras.get(B, []):
                    if not (len(prod) == 1 and prod[0] in self.variaveis):
                        if prod not in novas_regras[A]:
                            novas_regras[A].append(prod)

        self.regras = novas_regras

    def para_fnc(self):
        novas_regras = defaultdict(list)
        novos_simbolos = {}
        contador = 1

        def nova_variavel():
            nonlocal contador
            while True:
                var = f"X{contador}"
                contador += 1
                if var not in self.variaveis and var not in self.terminais:
                    return var

        for A in self.regras:
            for prod in self.regras[A]:
                if len(prod) == 1 and prod[0] in self.terminais:
                    novas_regras[A].append(prod)
                else:
                    nova_prod = []
                    for s in prod:
                        if s in self.terminais:
                            if s not in novos_simbolos:
                                X = nova_variavel()
                                novos_simbolos[s] = X
                            nova_prod.append(novos_simbolos[s])
                        else:
                            nova_prod.append(s)
                    novas_regras[A].append(nova_prod)

        for terminal, var in novos_simbolos.items():
            novas_regras[var].append([terminal])
            self.variaveis.add(var)

        final_regras = defaultdict(list)
        for A in novas_regras:
            for prod in novas_regras[A]:
                while len(prod) > 2:
                    X = nova_variavel()
                    self.variaveis.add(X)
                    final_regras[X].append(prod[1:])
                    prod = [prod[0], X]
                final_regras[A].append(prod)

        self.regras = final_regras

    def para_fng(self):
      variaveis_ordenadas = sorted(list(self.variaveis))
      novas_regras = dict(self.regras)

      for i, Ai in enumerate(variaveis_ordenadas):
          novas_producoes = []
          for prod in novas_regras.get(Ai, []):
              if prod and prod[0] in self.variaveis:
                  Aj = prod[0]
                  j = variaveis_ordenadas.index(Aj)
                  if j < i:
                      for gamma in novas_regras.get(Aj, []):
                          novas_producoes.append(gamma + prod[1:])
                  else:
                      novas_producoes.append(prod)
              else:
                  novas_producoes.append(prod)
          novas_regras[Ai] = novas_producoes

          diretas = []
          indiretas = []

          for prod in novas_regras[Ai]:
              if prod and prod[0] == Ai:
                  diretas.append(prod[1:])
              else:
                  indiretas.append(prod)

          if diretas:
              Ai_linha = Ai + "'"
              self.variaveis.add(Ai_linha)
              novas_regras[Ai] = []
              for beta in indiretas:
                  novas_regras[Ai].append(beta + [Ai_linha])
              novas_regras[Ai_linha] = []
              for alpha in diretas:
                  novas_regras[Ai_linha].append(alpha + [Ai_linha])
              novas_regras[Ai_linha].append(['ε'])

      final_regras = defaultdict(list)
      for A in novas_regras:
          for prod in novas_regras[A]:
              if prod and prod[0] in self.variaveis:
                  for alt in novas_regras.get(prod[0], []):
                      final_regras[A].append(alt + prod[1:])
              else:
                  final_regras[A].append(prod)

      self.regras = final_regras


    def fatorar_a_esquerda(self):
        novas_regras = defaultdict(list)
        contador = 1

        def nova_variavel():
            nonlocal contador
            while True:
                var = f"F{contador}"
                contador += 1
                if var not in self.variaveis:
                    return var

        for A, producoes in self.regras.items():
            prefixos = defaultdict(list)
            for prod in producoes:
                if prod:
                    prefixos[prod[0]].append(prod)

            if all(len(v) == 1 for v in prefixos.values()):
                novas_regras[A].extend(producoes)
            else:
                for simbolo, grupo in prefixos.items():
                    if len(grupo) == 1:
                        novas_regras[A].append(grupo[0])
                    else:
                        novo_nome = nova_variavel()
                        self.variaveis.add(novo_nome)
                        novas_regras[A].append([simbolo, novo_nome])
                        for prod in grupo:
                            sufixo = prod[1:] if len(prod) > 1 else ['ε']
                            novas_regras[novo_nome].append(sufixo)

        self.regras = novas_regras

    def remover_recursao_esquerda(self):
        novas_regras = defaultdict(list)
        contador = 1

        def nova_variavel():
            nonlocal contador
            while True:
                var = f"R{contador}"
                contador += 1
                if var not in self.variaveis:
                    return var

        for A, prods in self.regras.items():
            diretas = []
            indiretas = []

            for prod in prods:
                if prod and prod[0] == A:
                    diretas.append(prod[1:])
                else:
                    indiretas.append(prod)

            if diretas:
                novo = nova_variavel()
                self.variaveis.add(novo)
                for beta in indiretas:
                    novas_regras[A].append(beta + [novo])
                for alpha in diretas:
                    novas_regras[novo].append(alpha + [novo])
                novas_regras[novo].append(['ε'])
            else:
                novas_regras[A].extend(prods)

        self.regras = novas_regras

def gerar_substituicoes_vazias(prod, anulaveis):
    indices = [i for i, s in enumerate(prod) if s in anulaveis]
    subconjuntos = chain.from_iterable(combinations(indices, r) for r in range(1, len(indices)+1))
    resultados = []
    for subconjunto in subconjuntos:
        nova = [s for i, s in enumerate(prod) if i not in subconjunto]
        if nova not in resultados:
            resultados.append(nova)
    resultados.append(prod)
    return resultados

entrada = """
S -> aAa | bB
A -> a | aA
"""

g = Gramática(entrada)
g.exibir("Gramática Original")

g.remover_simbolos_inuteis()
g.exibir("Após remoção de símbolos inúteis")

g.remover_producoes_vazias()
g.exibir("Após remoção de produções vazias")

g.substituir_unitarias()
g.exibir("Após substituição de produções unitárias")

g.para_fnc()
g.exibir("Após conversão para FNC")

g.para_fng()
g.exibir("Após conversão para FNG")

g.fatorar_a_esquerda()
g.exibir("Após fatoração à esquerda")

g.remover_recursao_esquerda()
g.exibir("Após remoção de recursão à esquerda")