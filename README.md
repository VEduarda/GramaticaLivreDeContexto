# Explicação do Código de Gramática

O código define uma classe chamada `Gramática` que serve para representar e transformar gramáticas livres de contexto a partir de uma entrada textual o construtor da classe inicializa conjuntos para armazenar variáveis e terminais define a variável inicial da gramática como `None` e cria um dicionário de regras usando `defaultdict(list)` para facilitar o armazenamento das produções ele chama internamente um método chamado `_carregar_gramatica` que interpreta cada linha da entrada dividindo o lado esquerdo e direito da produção usando o símbolo `->` em seguida ele separa as alternativas de produção com base no caractere `|` e converte cada produção em uma lista de símbolos onde os terminais são reconhecidos por letras minúsculas ou símbolos especiais e as variáveis são adicionadas ao conjunto de variáveis

O método `exibir` imprime a gramática de forma legível mostrando cada variável seguida de suas produções separadas por `|` o método `remover_simbolos_inuteis` elimina símbolos que não geram cadeias terminais ou que não são acessíveis a partir do símbolo inicial ele faz isso em duas etapas a primeira identifica símbolos que podem gerar cadeias terminais chamadas de geradores e a segunda percorre a gramática a partir do símbolo inicial para identificar os símbolos acessíveis após isso remove todas as produções e variáveis que não são geradoras nem acessíveis

O método `remover_producoes_vazias` encontra todas as variáveis anuláveis ou seja aquelas que podem gerar `ε` diretamente ou indiretamente e para cada produção que contenha essas variáveis gera todas as combinações possíveis omitindo essas variáveis o objetivo é eliminar produções com `ε` sem alterar a linguagem da gramática se a variável inicial for anulável uma nova produção com `ε` é adicionada explicitamente

O método `substituir_unitarias` remove produções do tipo `A -> B` onde `B` é outra variável o algoritmo percorre as produções unitárias para encontrar o fechamento transitivo de cada variável ou seja todas as variáveis que podem ser alcançadas por meio de produções unitárias e então copia para `A` todas as produções não unitárias dessas variáveis

O método `para_fnc` transforma a gramática na forma normal de Chomsky que exige que todas as produções sejam da forma `A -> BC` ou `A -> a` inicialmente ele substitui os terminais por variáveis se estiverem acompanhados de outros símbolos usando variáveis auxiliares como `X1`, `X2` etc depois divide qualquer produção com mais de dois símbolos em múltiplas produções binárias criando novas variáveis intermediárias para manter a forma exigida

O método `para_fng` transforma a gramática na forma normal de Greibach onde cada produção começa com um terminal seguido de zero ou mais variáveis ele percorre as variáveis em ordem alfabética e sempre que encontra uma produção iniciada por uma variável anterior reescreve essa produção usando as produções da variável anterior se encontrar recursão à esquerda direta aplica o procedimento clássico de eliminação criando uma nova variável e reescrevendo as produções de forma a remover a recursividade

O método `fatorar_a_esquerda` reorganiza as produções para resolver ambiguidade quando há várias produções com prefixos comuns por exemplo se `A -> abc | abd` ele cria um novo símbolo para representar o sufixo e reescreve como `A -> abF1`, `F1 -> c | d` isso evita conflitos no momento da derivação e torna a gramática adequada para parsers do tipo preditivo

O método `remover_recursao_esquerda` elimina recursão à esquerda direta ao identificar produções como `A -> Aα | β` onde `β` não começa com `A` nesse caso ele cria uma nova variável como `R1` para separar as partes recursivas e não recursivas a produção é reescrita como `A -> βR1` e `R1 -> αR1 | ε` garantindo que as derivações comecem por cadeias não recursivas

A função `gerar_substituicoes_vazias` auxilia a remoção de produções vazias gerando todas as combinações possíveis de uma produção omitindo símbolos anuláveis ela retorna todas essas variações para que possam ser usadas no método `remover_producoes_vazias`

No final o código define uma gramática de entrada com as regras `S -> aAa | bB` e `A -> a | aA` cria um objeto da classe `Gramática` exibe a gramática original e em seguida aplica em ordem os métodos de remoção de símbolos inúteis remoção de produções vazias substituição de produções unitárias transformação para FNC transformação para FNG fatoração à esquerda e remoção de recursão à esquerda exibindo o resultado após cada etapa de transformação tudo isso permite acompanhar a evolução da gramática desde sua forma original até uma versão simplificada e estruturada para análises ou implementações de análise sintática em compiladores